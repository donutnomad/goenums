// DO NOT EDIT.
// code generated by goenums v0.4.0 at Jun 24 11:42:54.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums -vv examples/validation/status.go

package validation

import (
	"fmt"
	"iter"

	"github.com/zarldev/goenums/enums"

	"database/sql/driver"

	"gopkg.in/yaml.v3"
)

// ============================== TokenRequestStatus ==============================

// TokenRequestStatus is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type TokenRequestStatus struct {
	tokenRequestStatus
}

// Verify that TokenRequestStatus implements the Enum interface
var _ enums.Enum[int, TokenRequestStatus] = TokenRequestStatus{}

// tokenRequestStatusesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the TokenRequestStatus type.
type tokenRequestStatusesContainer struct {
	Step1Initialized      TokenRequestStatus // 1000, Step1 process started (PENDING)
	Step1Canceled         TokenRequestStatus // 9010, User manually canceled, process ended (CANCELED)
	Step1MarkAllowed      TokenRequestStatus // 1001, Marked as approved (PENDING)
	Step1MarkDenied       TokenRequestStatus // 1002, Marked as denied (PENDING)
	Step1Failed           TokenRequestStatus // 8010, Mark failed (others disagreed), waiting for user manual handling, re-enter process 1000, (FAILED)
	Step1Denied           TokenRequestStatus // 7011, Already denied, process ended (REJECTED)
	Step2WaitingPayment   TokenRequestStatus // 2000, Step1 passed, Step2 process started, user needs to start transferring Token to specified account (PENDING)
	Step2WaitingTxConfirm TokenRequestStatus // 2001, User has transferred, waiting for confirmation (at this time get user's TxHash) (PENDING)
	Step2Failed           TokenRequestStatus // 8020, Transfer inconsistent or transaction failed on chain, need to automatically return to process 2000 (automatically handled by program)
	Step3Initialized      TokenRequestStatus // 3000, Step2 received, Step3 process started (fill in bank TransactionID) (PENDING)
	Step3MarkAllowed      TokenRequestStatus // 3001, Marked as approved (PENDING)
	Step3Failed           TokenRequestStatus // 8030, Mark failed (others disagreed), waiting for user manual handling, re-enter process 3000 (FAILED)
	Step4Success          TokenRequestStatus // 4000
}

// TokenRequestStatusRaw is a type alias for the underlying enum type tokenRequestStatus.
// It provides direct access to the raw enum values for cases where you need
// to work with the underlying type directly.
type TokenRequestStatusRaw = tokenRequestStatus

// TokenRequestStatuses is a main entry point using the TokenRequestStatus type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var TokenRequestStatuses = tokenRequestStatusesContainer{
	Step1Initialized: TokenRequestStatus{
		tokenRequestStatus: Step1Initialized,
	},
	Step1Canceled: TokenRequestStatus{
		tokenRequestStatus: Step1Canceled,
	},
	Step1MarkAllowed: TokenRequestStatus{
		tokenRequestStatus: Step1MarkAllowed,
	},
	Step1MarkDenied: TokenRequestStatus{
		tokenRequestStatus: Step1MarkDenied,
	},
	Step1Failed: TokenRequestStatus{
		tokenRequestStatus: Step1Failed,
	},
	Step1Denied: TokenRequestStatus{
		tokenRequestStatus: Step1Denied,
	},
	Step2WaitingPayment: TokenRequestStatus{
		tokenRequestStatus: Step2WaitingPayment,
	},
	Step2WaitingTxConfirm: TokenRequestStatus{
		tokenRequestStatus: Step2WaitingTxConfirm,
	},
	Step2Failed: TokenRequestStatus{
		tokenRequestStatus: Step2Failed,
	},
	Step3Initialized: TokenRequestStatus{
		tokenRequestStatus: Step3Initialized,
	},
	Step3MarkAllowed: TokenRequestStatus{
		tokenRequestStatus: Step3MarkAllowed,
	},
	Step3Failed: TokenRequestStatus{
		tokenRequestStatus: Step3Failed,
	},
	Step4Success: TokenRequestStatus{
		tokenRequestStatus: Step4Success,
	},
}

// invalidTokenRequestStatus is an invalid sentinel value for TokenRequestStatus
var invalidTokenRequestStatus = TokenRequestStatus{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (t tokenRequestStatusesContainer) allSlice() []TokenRequestStatus {
	return []TokenRequestStatus{
		TokenRequestStatuses.Step1Initialized,
		TokenRequestStatuses.Step1Canceled,
		TokenRequestStatuses.Step1MarkAllowed,
		TokenRequestStatuses.Step1MarkDenied,
		TokenRequestStatuses.Step1Failed,
		TokenRequestStatuses.Step1Denied,
		TokenRequestStatuses.Step2WaitingPayment,
		TokenRequestStatuses.Step2WaitingTxConfirm,
		TokenRequestStatuses.Step2Failed,
		TokenRequestStatuses.Step3Initialized,
		TokenRequestStatuses.Step3MarkAllowed,
		TokenRequestStatuses.Step3Failed,
		TokenRequestStatuses.Step4Success,
	}
}

// validTokenRequestStatuses is a map of enum values to their validity
var validTokenRequestStatuses = map[TokenRequestStatus]bool{
	TokenRequestStatuses.Step1Initialized:      true,
	TokenRequestStatuses.Step1Canceled:         true,
	TokenRequestStatuses.Step1MarkAllowed:      true,
	TokenRequestStatuses.Step1MarkDenied:       true,
	TokenRequestStatuses.Step1Failed:           true,
	TokenRequestStatuses.Step1Denied:           true,
	TokenRequestStatuses.Step2WaitingPayment:   true,
	TokenRequestStatuses.Step2WaitingTxConfirm: true,
	TokenRequestStatuses.Step2Failed:           true,
	TokenRequestStatuses.Step3Initialized:      true,
	TokenRequestStatuses.Step3MarkAllowed:      true,
	TokenRequestStatuses.Step3Failed:           true,
	TokenRequestStatuses.Step4Success:          true,
}

// IsValid checks whether the TokenRequestStatuses value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (t TokenRequestStatus) IsValid() bool {
	return validTokenRequestStatuses[t]
}

// TokenRequestStatusName is a string type for enum name constants
type TokenRequestStatusName string

// TokenRequestStatus name constants
const (
	TokenRequestStatusNameStep1Initialized      TokenRequestStatusName = "Step1Initialized"
	TokenRequestStatusNameStep1Canceled         TokenRequestStatusName = "Step1Canceled"
	TokenRequestStatusNameStep1MarkAllowed      TokenRequestStatusName = "Step1MarkAllowed"
	TokenRequestStatusNameStep1MarkDenied       TokenRequestStatusName = "Step1MarkDenied"
	TokenRequestStatusNameStep1Failed           TokenRequestStatusName = "Step1Failed"
	TokenRequestStatusNameStep1Denied           TokenRequestStatusName = "Step1Denied"
	TokenRequestStatusNameStep2WaitingPayment   TokenRequestStatusName = "Step2WaitingPayment"
	TokenRequestStatusNameStep2WaitingTxConfirm TokenRequestStatusName = "Step2WaitingTxConfirm"
	TokenRequestStatusNameStep2Failed           TokenRequestStatusName = "Step2Failed"
	TokenRequestStatusNameStep3Initialized      TokenRequestStatusName = "Step3Initialized"
	TokenRequestStatusNameStep3MarkAllowed      TokenRequestStatusName = "Step3MarkAllowed"
	TokenRequestStatusNameStep3Failed           TokenRequestStatusName = "Step3Failed"
	TokenRequestStatusNameStep4Success          TokenRequestStatusName = "Step4Success"
)

// tokenrequeststatusNamesMap is a map of enum values to their canonical absolute names
var tokenrequeststatusNamesMap = map[TokenRequestStatus]string{
	TokenRequestStatuses.Step1Initialized:      string(TokenRequestStatusNameStep1Initialized),
	TokenRequestStatuses.Step1Canceled:         string(TokenRequestStatusNameStep1Canceled),
	TokenRequestStatuses.Step1MarkAllowed:      string(TokenRequestStatusNameStep1MarkAllowed),
	TokenRequestStatuses.Step1MarkDenied:       string(TokenRequestStatusNameStep1MarkDenied),
	TokenRequestStatuses.Step1Failed:           string(TokenRequestStatusNameStep1Failed),
	TokenRequestStatuses.Step1Denied:           string(TokenRequestStatusNameStep1Denied),
	TokenRequestStatuses.Step2WaitingPayment:   string(TokenRequestStatusNameStep2WaitingPayment),
	TokenRequestStatuses.Step2WaitingTxConfirm: string(TokenRequestStatusNameStep2WaitingTxConfirm),
	TokenRequestStatuses.Step2Failed:           string(TokenRequestStatusNameStep2Failed),
	TokenRequestStatuses.Step3Initialized:      string(TokenRequestStatusNameStep3Initialized),
	TokenRequestStatuses.Step3MarkAllowed:      string(TokenRequestStatusNameStep3MarkAllowed),
	TokenRequestStatuses.Step3Failed:           string(TokenRequestStatusNameStep3Failed),
	TokenRequestStatuses.Step4Success:          string(TokenRequestStatusNameStep4Success),
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (t TokenRequestStatus) String() string {
	if str, ok := tokenrequeststatusNamesMap[t]; ok {
		return str
	}
	return fmt.Sprintf("tokenrequeststatus(%v)", t.tokenRequestStatus)
}

// Val implements the Enum interface.
// It returns the underlying enum value.
func (t TokenRequestStatus) Val() int {
	return int(t.tokenRequestStatus)
}

// All implements the Enum interface.
// It returns an iterator over all enum values.
func (t TokenRequestStatus) All() iter.Seq[TokenRequestStatus] {
	return func(yield func(TokenRequestStatus) bool) {
		for _, v := range TokenRequestStatuses.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// FromName implements the Enum interface.
// It finds an enum value by name and returns the enum instance and a boolean indicating if found.
func (t TokenRequestStatus) FromName(name string) (TokenRequestStatus, bool) {
	for enum, enumName := range tokenrequeststatusNamesMap {
		if enumName == name {
			return enum, true
		}
	}
	var zero TokenRequestStatus
	return zero, false
}

// FromValue implements the Enum interface.
// It finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
func (t TokenRequestStatus) FromValue(value int) (TokenRequestStatus, bool) {
	for v := range t.All() {
		if v.Val() == value {
			return v, true
		}
	}
	var zero TokenRequestStatus
	return zero, false
}

// SerdeFormat implements the Enum interface.
// It returns the format used for serialization.
func (t TokenRequestStatus) SerdeFormat() enums.Format {
	return enums.FormatValue
}

// Name implements the Enum interface.
// It returns the name of the current enum value.
func (t TokenRequestStatus) Name() string {
	if str, ok := tokenrequeststatusNamesMap[t]; ok {
		return str
	}
	return fmt.Sprintf("tokenrequeststatus(%v)", t.tokenRequestStatus)
}

// MarshalJSON implements the json.Marshaler interface for TokenRequestStatus.
// It returns the JSON representation of the enum value as a byte slice.
func (t TokenRequestStatus) MarshalJSON() ([]byte, error) {
	return enums.MarshalJSON(t, t.tokenRequestStatus)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TokenRequestStatus.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (t *TokenRequestStatus) UnmarshalJSON(data []byte) error {
	result, err := enums.UnmarshalJSON(*t, data)
	if err != nil {
		return err
	}
	*t = *result
	return nil
}

// Scan implements the database/sql.Scanner interface for TokenRequestStatus.
// It parses the database value and stores it in the enum.
// It returns an error if the value cannot be parsed.
func (t *TokenRequestStatus) Scan(value any) error {
	result, err := enums.SQLScan(*t, value)
	if err != nil {
		return err
	}
	*t = *result
	return nil
}

// Value implements the database/sql/driver.Valuer interface for TokenRequestStatus.
// It returns the database representation of the enum value.
func (t TokenRequestStatus) Value() (driver.Value, error) {
	return enums.SQLValue(t)
}

// All returns an iterator over all enum values.
// This is a convenience method that delegates to the zero value enum instance.
func (t tokenRequestStatusesContainer) All() iter.Seq[TokenRequestStatus] {
	return TokenRequestStatus{}.All()
}

// FromName finds an enum value by name and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (t tokenRequestStatusesContainer) FromName(name string) (TokenRequestStatus, bool) {
	return TokenRequestStatus{}.FromName(name)
}

// FromValue finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (t tokenRequestStatusesContainer) FromValue(value int) (TokenRequestStatus, bool) {
	return TokenRequestStatus{}.FromValue(value)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [13]struct{}
	_ = x[Step1Initialized-1000]
	_ = x[Step1Canceled-9010]
	_ = x[Step1MarkAllowed-1001]
	_ = x[Step1MarkDenied-1002]
	_ = x[Step1Failed-8010]
	_ = x[Step1Denied-7011]
	_ = x[Step2WaitingPayment-2000]
	_ = x[Step2WaitingTxConfirm-2001]
	_ = x[Step2Failed-8020]
	_ = x[Step3Initialized-3000]
	_ = x[Step3MarkAllowed-3001]
	_ = x[Step3Failed-8030]
	_ = x[Step4Success-4000]
}

// ================================= StringStatus =================================

// StringStatus is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type StringStatus struct {
	stringStatus
}

// Verify that StringStatus implements the Enum interface
var _ enums.Enum[int, StringStatus] = StringStatus{}

// stringStatusesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the StringStatus type.
type stringStatusesContainer struct {
	None           StringStatus
	StringActive   StringStatus
	StringInactive StringStatus
}

// StringStatusRaw is a type alias for the underlying enum type stringStatus.
// It provides direct access to the raw enum values for cases where you need
// to work with the underlying type directly.
type StringStatusRaw = stringStatus

// StringStatuses is a main entry point using the StringStatus type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var StringStatuses = stringStatusesContainer{
	None: StringStatus{
		stringStatus: none,
	},
	StringActive: StringStatus{
		stringStatus: StringActive,
	},
	StringInactive: StringStatus{
		stringStatus: StringInactive,
	},
}

// invalidStringStatus is an invalid sentinel value for StringStatus
var invalidStringStatus = StringStatus{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (s stringStatusesContainer) allSlice() []StringStatus {
	return []StringStatus{
		StringStatuses.None,
		StringStatuses.StringActive,
		StringStatuses.StringInactive,
	}
}

// validStringStatuses is a map of enum values to their validity
var validStringStatuses = map[StringStatus]bool{
	StringStatuses.None:           false,
	StringStatuses.StringActive:   true,
	StringStatuses.StringInactive: true,
}

// IsValid checks whether the StringStatuses value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (s StringStatus) IsValid() bool {
	return validStringStatuses[s]
}

// stringstatusNames is a constant string slice containing all enum values cononical absolute names
const stringstatusNames = "noneActiveInactive"

// stringstatusNamesMap is a map of enum values to their canonical absolute
// name positions within the stringstatusNames string slice
var stringstatusNamesMap = map[StringStatus]string{
	StringStatuses.None:           stringstatusNames[0:4],
	StringStatuses.StringActive:   stringstatusNames[4:10],
	StringStatuses.StringInactive: stringstatusNames[10:18],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (s StringStatus) String() string {
	if str, ok := stringstatusNamesMap[s]; ok {
		return str
	}
	return fmt.Sprintf("stringstatus(%v)", s.stringStatus)
}

// Val implements the Enum interface.
// It returns the underlying enum value.
func (s StringStatus) Val() int {
	return int(s.stringStatus)
}

// All implements the Enum interface.
// It returns an iterator over all enum values.
func (s StringStatus) All() iter.Seq[StringStatus] {
	return func(yield func(StringStatus) bool) {
		for _, v := range StringStatuses.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// FromName implements the Enum interface.
// It finds an enum value by name and returns the enum instance and a boolean indicating if found.
func (s StringStatus) FromName(name string) (StringStatus, bool) {
	for enum, enumName := range stringstatusNamesMap {
		if enumName == name {
			return enum, true
		}
	}
	var zero StringStatus
	return zero, false
}

// FromValue implements the Enum interface.
// It finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
func (s StringStatus) FromValue(value int) (StringStatus, bool) {
	for v := range s.All() {
		if v.Val() == value {
			return v, true
		}
	}
	var zero StringStatus
	return zero, false
}

// SerdeFormat implements the Enum interface.
// It returns the format used for serialization.
func (s StringStatus) SerdeFormat() enums.Format {
	return enums.FormatName
}

// Name implements the Enum interface.
// It returns the name of the current enum value.
func (s StringStatus) Name() string {
	if str, ok := stringstatusNamesMap[s]; ok {
		return str
	}
	return fmt.Sprintf("stringstatus(%v)", s.stringStatus)
}

// MarshalJSON implements the json.Marshaler interface for StringStatus.
// It returns the JSON representation of the enum value as a byte slice.
func (s StringStatus) MarshalJSON() ([]byte, error) {
	return enums.MarshalJSON(s, s.stringStatus)
}

// UnmarshalJSON implements the json.Unmarshaler interface for StringStatus.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (s *StringStatus) UnmarshalJSON(data []byte) error {
	result, err := enums.UnmarshalJSON(*s, data)
	if err != nil {
		return err
	}
	*s = *result
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for StringStatus.
// It returns the text representation of the enum value as a byte slice.
func (s StringStatus) MarshalText() ([]byte, error) {
	return enums.MarshalText(s, s.stringStatus)
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for StringStatus.
// It parses the text representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (s *StringStatus) UnmarshalText(data []byte) error {
	result, err := enums.UnmarshalText(*s, data)
	if err != nil {
		return err
	}
	*s = *result
	return nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for StringStatus.
// It returns the binary representation of the enum value as a byte slice.
func (s StringStatus) MarshalBinary() ([]byte, error) {
	return enums.MarshalBinary(s, s.stringStatus)
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for StringStatus.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (s *StringStatus) UnmarshalBinary(data []byte) error {
	result, err := enums.UnmarshalBinary(*s, data)
	if err != nil {
		return err
	}
	*s = *result
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for StringStatus.
// It returns the YAML representation of the enum value.
func (s StringStatus) MarshalYAML() (any, error) {
	return enums.MarshalYAML(s, s.stringStatus)
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for StringStatus.
// It parses the YAML representation of the enum value.
// It returns an error if the YAML does not contain a valid enum value.
func (s *StringStatus) UnmarshalYAML(node *yaml.Node) error {
	result, err := enums.UnmarshalYAML(*s, node)
	if err != nil {
		return err
	}
	*s = *result
	return nil
}

// All returns an iterator over all enum values.
// This is a convenience method that delegates to the zero value enum instance.
func (s stringStatusesContainer) All() iter.Seq[StringStatus] {
	return StringStatus{}.All()
}

// FromName finds an enum value by name and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (s stringStatusesContainer) FromName(name string) (StringStatus, bool) {
	return StringStatus{}.FromName(name)
}

// FromValue finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (s stringStatusesContainer) FromValue(value int) (StringStatus, bool) {
	return StringStatus{}.FromValue(value)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [3]struct{}
	_ = x[none-0]
	_ = x[StringActive-1]
	_ = x[StringInactive-2]
}

// ================================= BytesStatus ==================================

// BytesStatus is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type BytesStatus struct {
	bytesStatus
}

// Verify that BytesStatus implements the Enum interface
var _ enums.Enum[int, BytesStatus] = BytesStatus{}

// bytesStatusesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the BytesStatus type.
type bytesStatusesContainer struct {
	BytesActive   BytesStatus
	BytesInactive BytesStatus
}

// BytesStatusRaw is a type alias for the underlying enum type bytesStatus.
// It provides direct access to the raw enum values for cases where you need
// to work with the underlying type directly.
type BytesStatusRaw = bytesStatus

// BytesStatuses is a main entry point using the BytesStatus type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var BytesStatuses = bytesStatusesContainer{
	BytesActive: BytesStatus{
		bytesStatus: BytesActive,
	},
	BytesInactive: BytesStatus{
		bytesStatus: BytesInactive,
	},
}

// invalidBytesStatus is an invalid sentinel value for BytesStatus
var invalidBytesStatus = BytesStatus{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (b bytesStatusesContainer) allSlice() []BytesStatus {
	return []BytesStatus{
		BytesStatuses.BytesActive,
		BytesStatuses.BytesInactive,
	}
}

// validBytesStatuses is a map of enum values to their validity
var validBytesStatuses = map[BytesStatus]bool{
	BytesStatuses.BytesActive:   true,
	BytesStatuses.BytesInactive: true,
}

// IsValid checks whether the BytesStatuses value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (b BytesStatus) IsValid() bool {
	return validBytesStatuses[b]
}

// bytesstatusNames is a constant string slice containing all enum values cononical absolute names
const bytesstatusNames = "ActiveInactive"

// bytesstatusNamesMap is a map of enum values to their canonical absolute
// name positions within the bytesstatusNames string slice
var bytesstatusNamesMap = map[BytesStatus]string{
	BytesStatuses.BytesActive:   bytesstatusNames[0:6],
	BytesStatuses.BytesInactive: bytesstatusNames[6:14],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (b BytesStatus) String() string {
	if str, ok := bytesstatusNamesMap[b]; ok {
		return str
	}
	return fmt.Sprintf("bytesstatus(%v)", b.bytesStatus)
}

// Val implements the Enum interface.
// It returns the underlying enum value.
func (b BytesStatus) Val() int {
	return int(b.bytesStatus)
}

// All implements the Enum interface.
// It returns an iterator over all enum values.
func (b BytesStatus) All() iter.Seq[BytesStatus] {
	return func(yield func(BytesStatus) bool) {
		for _, v := range BytesStatuses.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// FromName implements the Enum interface.
// It finds an enum value by name and returns the enum instance and a boolean indicating if found.
func (b BytesStatus) FromName(name string) (BytesStatus, bool) {
	for enum, enumName := range bytesstatusNamesMap {
		if enumName == name {
			return enum, true
		}
	}
	var zero BytesStatus
	return zero, false
}

// FromValue implements the Enum interface.
// It finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
func (b BytesStatus) FromValue(value int) (BytesStatus, bool) {
	for v := range b.All() {
		if v.Val() == value {
			return v, true
		}
	}
	var zero BytesStatus
	return zero, false
}

// SerdeFormat implements the Enum interface.
// It returns the format used for serialization.
func (b BytesStatus) SerdeFormat() enums.Format {
	return enums.FormatName
}

// Name implements the Enum interface.
// It returns the name of the current enum value.
func (b BytesStatus) Name() string {
	if str, ok := bytesstatusNamesMap[b]; ok {
		return str
	}
	return fmt.Sprintf("bytesstatus(%v)", b.bytesStatus)
}

// MarshalJSON implements the json.Marshaler interface for BytesStatus.
// It returns the JSON representation of the enum value as a byte slice.
func (b BytesStatus) MarshalJSON() ([]byte, error) {
	return enums.MarshalJSON(b, b.bytesStatus)
}

// UnmarshalJSON implements the json.Unmarshaler interface for BytesStatus.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (b *BytesStatus) UnmarshalJSON(data []byte) error {
	result, err := enums.UnmarshalJSON(*b, data)
	if err != nil {
		return err
	}
	*b = *result
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for BytesStatus.
// It returns the text representation of the enum value as a byte slice.
func (b BytesStatus) MarshalText() ([]byte, error) {
	return enums.MarshalText(b, b.bytesStatus)
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for BytesStatus.
// It parses the text representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (b *BytesStatus) UnmarshalText(data []byte) error {
	result, err := enums.UnmarshalText(*b, data)
	if err != nil {
		return err
	}
	*b = *result
	return nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for BytesStatus.
// It returns the binary representation of the enum value as a byte slice.
func (b BytesStatus) MarshalBinary() ([]byte, error) {
	return enums.MarshalBinary(b, b.bytesStatus)
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for BytesStatus.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (b *BytesStatus) UnmarshalBinary(data []byte) error {
	result, err := enums.UnmarshalBinary(*b, data)
	if err != nil {
		return err
	}
	*b = *result
	return nil
}

// All returns an iterator over all enum values.
// This is a convenience method that delegates to the zero value enum instance.
func (b bytesStatusesContainer) All() iter.Seq[BytesStatus] {
	return BytesStatus{}.All()
}

// FromName finds an enum value by name and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (b bytesStatusesContainer) FromName(name string) (BytesStatus, bool) {
	return BytesStatus{}.FromName(name)
}

// FromValue finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (b bytesStatusesContainer) FromValue(value int) (BytesStatus, bool) {
	return BytesStatus{}.FromValue(value)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [2]struct{}
	_ = x[BytesActive-1]
	_ = x[BytesInactive-2]
}

// =============================== PrimitiveStatus ================================

// PrimitiveStatus is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type PrimitiveStatus struct {
	primitiveStatus
}

// Verify that PrimitiveStatus implements the Enum interface
var _ enums.Enum[float32, PrimitiveStatus] = PrimitiveStatus{}

// primitiveStatusesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the PrimitiveStatus type.
type primitiveStatusesContainer struct {
	PrimitiveActive   PrimitiveStatus
	PrimitiveInactive PrimitiveStatus
}

// PrimitiveStatusRaw is a type alias for the underlying enum type primitiveStatus.
// It provides direct access to the raw enum values for cases where you need
// to work with the underlying type directly.
type PrimitiveStatusRaw = primitiveStatus

// PrimitiveStatuses is a main entry point using the PrimitiveStatus type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var PrimitiveStatuses = primitiveStatusesContainer{
	PrimitiveActive: PrimitiveStatus{
		primitiveStatus: PrimitiveActive,
	},
	PrimitiveInactive: PrimitiveStatus{
		primitiveStatus: PrimitiveInactive,
	},
}

// invalidPrimitiveStatus is an invalid sentinel value for PrimitiveStatus
var invalidPrimitiveStatus = PrimitiveStatus{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (p primitiveStatusesContainer) allSlice() []PrimitiveStatus {
	return []PrimitiveStatus{
		PrimitiveStatuses.PrimitiveActive,
		PrimitiveStatuses.PrimitiveInactive,
	}
}

// validPrimitiveStatuses is a map of enum values to their validity
var validPrimitiveStatuses = map[PrimitiveStatus]bool{
	PrimitiveStatuses.PrimitiveActive:   true,
	PrimitiveStatuses.PrimitiveInactive: true,
}

// IsValid checks whether the PrimitiveStatuses value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p PrimitiveStatus) IsValid() bool {
	return validPrimitiveStatuses[p]
}

// primitivestatusNames is a constant string slice containing all enum values cononical absolute names
const primitivestatusNames = "ActiveInactive"

// primitivestatusNamesMap is a map of enum values to their canonical absolute
// name positions within the primitivestatusNames string slice
var primitivestatusNamesMap = map[PrimitiveStatus]string{
	PrimitiveStatuses.PrimitiveActive:   primitivestatusNames[0:6],
	PrimitiveStatuses.PrimitiveInactive: primitivestatusNames[6:14],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (p PrimitiveStatus) String() string {
	if str, ok := primitivestatusNamesMap[p]; ok {
		return str
	}
	return fmt.Sprintf("primitivestatus(%v)", p.primitiveStatus)
}

// Val implements the Enum interface.
// It returns the underlying enum value.
func (p PrimitiveStatus) Val() float32 {
	return float32(p.primitiveStatus)
}

// All implements the Enum interface.
// It returns an iterator over all enum values.
func (p PrimitiveStatus) All() iter.Seq[PrimitiveStatus] {
	return func(yield func(PrimitiveStatus) bool) {
		for _, v := range PrimitiveStatuses.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// FromName implements the Enum interface.
// It finds an enum value by name and returns the enum instance and a boolean indicating if found.
func (p PrimitiveStatus) FromName(name string) (PrimitiveStatus, bool) {
	for enum, enumName := range primitivestatusNamesMap {
		if enumName == name {
			return enum, true
		}
	}
	var zero PrimitiveStatus
	return zero, false
}

// FromValue implements the Enum interface.
// It finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
func (p PrimitiveStatus) FromValue(value float32) (PrimitiveStatus, bool) {
	for v := range p.All() {
		if v.Val() == value {
			return v, true
		}
	}
	var zero PrimitiveStatus
	return zero, false
}

// SerdeFormat implements the Enum interface.
// It returns the format used for serialization.
func (p PrimitiveStatus) SerdeFormat() enums.Format {
	return enums.FormatValue
}

// Name implements the Enum interface.
// It returns the name of the current enum value.
func (p PrimitiveStatus) Name() string {
	if str, ok := primitivestatusNamesMap[p]; ok {
		return str
	}
	return fmt.Sprintf("primitivestatus(%v)", p.primitiveStatus)
}

// MarshalJSON implements the json.Marshaler interface for PrimitiveStatus.
// It returns the JSON representation of the enum value as a byte slice.
func (p PrimitiveStatus) MarshalJSON() ([]byte, error) {
	return enums.MarshalJSON(p, p.primitiveStatus)
}

// UnmarshalJSON implements the json.Unmarshaler interface for PrimitiveStatus.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (p *PrimitiveStatus) UnmarshalJSON(data []byte) error {
	result, err := enums.UnmarshalJSON(*p, data)
	if err != nil {
		return err
	}
	*p = *result
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for PrimitiveStatus.
// It returns the text representation of the enum value as a byte slice.
func (p PrimitiveStatus) MarshalText() ([]byte, error) {
	return enums.MarshalText(p, p.primitiveStatus)
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PrimitiveStatus.
// It parses the text representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (p *PrimitiveStatus) UnmarshalText(data []byte) error {
	result, err := enums.UnmarshalText(*p, data)
	if err != nil {
		return err
	}
	*p = *result
	return nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for PrimitiveStatus.
// It returns the binary representation of the enum value as a byte slice.
func (p PrimitiveStatus) MarshalBinary() ([]byte, error) {
	return enums.MarshalBinary(p, p.primitiveStatus)
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for PrimitiveStatus.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (p *PrimitiveStatus) UnmarshalBinary(data []byte) error {
	result, err := enums.UnmarshalBinary(*p, data)
	if err != nil {
		return err
	}
	*p = *result
	return nil
}

// All returns an iterator over all enum values.
// This is a convenience method that delegates to the zero value enum instance.
func (p primitiveStatusesContainer) All() iter.Seq[PrimitiveStatus] {
	return PrimitiveStatus{}.All()
}

// FromName finds an enum value by name and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (p primitiveStatusesContainer) FromName(name string) (PrimitiveStatus, bool) {
	return PrimitiveStatus{}.FromName(name)
}

// FromValue finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (p primitiveStatusesContainer) FromValue(value float32) (PrimitiveStatus, bool) {
	return PrimitiveStatus{}.FromValue(value)
}

// ================================= OrderStatus ==================================

// OrderStatus is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type OrderStatus struct {
	orderStatus
}

// Verify that OrderStatus implements the Enum interface
var _ enums.Enum[int, OrderStatus] = OrderStatus{}

// orderStatusesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the OrderStatus type.
type orderStatusesContainer struct {
	OrderPending   OrderStatus // state: -> xProcessing, orderCancelled, 我是注释哦哦
	XProcessing    OrderStatus // state: -> orderShipped, orderFailed, 我是注释哦哦2
	OrderShipped   OrderStatus // state: -> orderDelivered, 我是注释哦哦3
	OrderDelivered OrderStatus // state: [final], 我是注释哦哦4
	OrderCancelled OrderStatus // state: [final]
	OrderFailed    OrderStatus // state: -> orderPending, orderCancelled
}

// OrderStatusRaw is a type alias for the underlying enum type orderStatus.
// It provides direct access to the raw enum values for cases where you need
// to work with the underlying type directly.
type OrderStatusRaw = orderStatus

// OrderStatuses is a main entry point using the OrderStatus type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var OrderStatuses = orderStatusesContainer{
	OrderPending: OrderStatus{
		orderStatus: orderPending,
	},
	XProcessing: OrderStatus{
		orderStatus: xProcessing,
	},
	OrderShipped: OrderStatus{
		orderStatus: orderShipped,
	},
	OrderDelivered: OrderStatus{
		orderStatus: orderDelivered,
	},
	OrderCancelled: OrderStatus{
		orderStatus: orderCancelled,
	},
	OrderFailed: OrderStatus{
		orderStatus: orderFailed,
	},
}

// invalidOrderStatus is an invalid sentinel value for OrderStatus
var invalidOrderStatus = OrderStatus{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (o orderStatusesContainer) allSlice() []OrderStatus {
	return []OrderStatus{
		OrderStatuses.OrderPending,
		OrderStatuses.XProcessing,
		OrderStatuses.OrderShipped,
		OrderStatuses.OrderDelivered,
		OrderStatuses.OrderCancelled,
		OrderStatuses.OrderFailed,
	}
}

// validOrderStatuses is a map of enum values to their validity
var validOrderStatuses = map[OrderStatus]bool{
	OrderStatuses.OrderPending:   false,
	OrderStatuses.XProcessing:    false,
	OrderStatuses.OrderShipped:   false,
	OrderStatuses.OrderDelivered: false,
	OrderStatuses.OrderCancelled: false,
	OrderStatuses.OrderFailed:    false,
}

// IsValid checks whether the OrderStatuses value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (o OrderStatus) IsValid() bool {
	return validOrderStatuses[o]
}

// orderstatusNames is a constant string slice containing all enum values cononical absolute names
const orderstatusNames = "PendingProcessingShippedDeliveredCancelledFailed"

// orderstatusNamesMap is a map of enum values to their canonical absolute
// name positions within the orderstatusNames string slice
var orderstatusNamesMap = map[OrderStatus]string{
	OrderStatuses.OrderPending:   orderstatusNames[0:7],
	OrderStatuses.XProcessing:    orderstatusNames[7:17],
	OrderStatuses.OrderShipped:   orderstatusNames[17:24],
	OrderStatuses.OrderDelivered: orderstatusNames[24:33],
	OrderStatuses.OrderCancelled: orderstatusNames[33:42],
	OrderStatuses.OrderFailed:    orderstatusNames[42:48],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (o OrderStatus) String() string {
	if str, ok := orderstatusNamesMap[o]; ok {
		return str
	}
	return fmt.Sprintf("orderstatus(%v)", o.orderStatus)
}

// Val implements the Enum interface.
// It returns the underlying enum value.
func (o OrderStatus) Val() int {
	return int(o.orderStatus)
}

// All implements the Enum interface.
// It returns an iterator over all enum values.
func (o OrderStatus) All() iter.Seq[OrderStatus] {
	return func(yield func(OrderStatus) bool) {
		for _, v := range OrderStatuses.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// FromName implements the Enum interface.
// It finds an enum value by name and returns the enum instance and a boolean indicating if found.
func (o OrderStatus) FromName(name string) (OrderStatus, bool) {
	for enum, enumName := range orderstatusNamesMap {
		if enumName == name {
			return enum, true
		}
	}
	var zero OrderStatus
	return zero, false
}

// FromValue implements the Enum interface.
// It finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
func (o OrderStatus) FromValue(value int) (OrderStatus, bool) {
	for v := range o.All() {
		if v.Val() == value {
			return v, true
		}
	}
	var zero OrderStatus
	return zero, false
}

// SerdeFormat implements the Enum interface.
// It returns the format used for serialization.
func (o OrderStatus) SerdeFormat() enums.Format {
	return enums.FormatName
}

// Name implements the Enum interface.
// It returns the name of the current enum value.
func (o OrderStatus) Name() string {
	if str, ok := orderstatusNamesMap[o]; ok {
		return str
	}
	return fmt.Sprintf("orderstatus(%v)", o.orderStatus)
}

// All returns an iterator over all enum values.
// This is a convenience method that delegates to the zero value enum instance.
func (o orderStatusesContainer) All() iter.Seq[OrderStatus] {
	return OrderStatus{}.All()
}

// FromName finds an enum value by name and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (o orderStatusesContainer) FromName(name string) (OrderStatus, bool) {
	return OrderStatus{}.FromName(name)
}

// FromValue finds an enum instance by its underlying value and returns the enum instance and a boolean indicating if found.
// This is a convenience method that delegates to the zero value enum instance.
func (o orderStatusesContainer) FromValue(value int) (OrderStatus, bool) {
	return OrderStatus{}.FromValue(value)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [6]struct{}
	_ = x[orderPending-0]
	_ = x[xProcessing-0]
	_ = x[orderShipped-1]
	_ = x[orderDelivered-2]
	_ = x[orderCancelled-3]
	_ = x[orderFailed-4]
}

// CanTransitionTo checks if the current state can transition to the target state.
// Returns true if the transition is allowed, false otherwise.
func (o OrderStatus) CanTransitionTo(target OrderStatus) bool {
	transitions := o.ValidTransitions()
	for _, validTarget := range transitions {
		if validTarget == target {
			return true
		}
	}
	return false
}

// ValidTransitions returns all valid target states that this state can transition to.
// Returns an empty slice if this is a terminal state or has no defined transitions.
func (o OrderStatus) ValidTransitions() []OrderStatus {
	if o == OrderStatuses.OrderPending {
		return []OrderStatus{
			OrderStatuses.XProcessing,
			OrderStatuses.OrderCancelled,
		}
	}
	if o == OrderStatuses.XProcessing {
		return []OrderStatus{
			OrderStatuses.OrderShipped,
			OrderStatuses.OrderFailed,
		}
	}
	if o == OrderStatuses.OrderShipped {
		return []OrderStatus{
			OrderStatuses.OrderDelivered,
		}
	}
	if o == OrderStatuses.OrderFailed {
		return []OrderStatus{
			OrderStatuses.OrderPending,
			OrderStatuses.OrderCancelled,
		}
	}
	return []OrderStatus{}
}

// IsTerminalState returns true if this state is a terminal (final) state.
// Terminal states cannot transition to any other state.
func (o OrderStatus) IsTerminalState() bool {
	if o == OrderStatuses.OrderDelivered {
		return true
	}
	if o == OrderStatuses.OrderCancelled {
		return true
	}
	return false
}
